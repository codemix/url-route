<link rel="import" href="../polymer/polymer.html">

<!--
Custom Element providing URL routing.

##### Example

    <template is="url-router" pattern="/pages/<page>">
      <h1>Showing the {{page}} page!</h1>
    </template>

@element url-router
@blurb Custom Element providing URL routing.
@status alpha
@homepage http://codemix.github.io/url-router
-->
<polymer-element name="url-router" extends="template" attributes="pattern">

  <script>
  (function () {

    function trim (input, chars) {
      var c;
      chars = chars || ' ';
      while (input.length && ~chars.indexOf(input.charAt(0))) {
        input = input.slice(1);
      }
      while (input.length && ~chars.indexOf(input.charAt(input.length - 1))) {
        input = input.slice(0, -1);
      }
      return input;
    }

    (function (history){
      var pushState = history.pushState,
          replaceState = history.replaceState;
      history.pushState = function (state) {
        var result = pushState.apply(history, arguments);
        window.dispatchEvent(new CustomEvent('url-router-history-change', {
          state: state,
          location: document.location
        }));
        return result;
      },
      history.replaceState = function (state) {
        var result = replaceState.apply(history, arguments);
        window.dispatchEvent(new CustomEvent('url-router-history-change', {
          state: state,
          location: document.location
        }));
        return result;
      }
    })(window.history);


    Polymer('url-router', {
      createdCallback: function() {
        var self = this;
        this.changeEventHandler = function () {
          var changes = self.routeChanges();
          if (changes !== false) {
            console.log('detected changes', changes);
            self.model = changes;
          }
        };

        this.pattern = this.attributes.pattern ? this.attributes.pattern.nodeValue : '';
        this.name = this.attributes.name ? this.attributes.name.nodeValue : '';
        this.syntax = this.bindingDelegate = this.makeSyntax();


        // delay stamping until polymer-ready so that url-router is not
        // required to load last.
        addEventListener('polymer-ready', function() {
          this.model = this.matchRoute();
          if (this.model) {
            console.log('matched', this);
          }
          this.setAttribute('bind', '');
          this.async(function() {
            // don't keep references to node contents
            this.$ = {};
            // template stamping is asynchronous so stamping isn't complete
            // by polymer-ready; fire an event so users can use stamped elements
            this.fire('template-bound');
          });
        }.bind(this));

      },
      attached: function () {
        console.log('attaching...', this.pattern);
        addEventListener('url-router-history-change', this.changeEventHandler);
        addEventListener('popstate', this.changeEventHandler);
        addEventListener('hashchange', this.changeEventHandler);
      },
      detached: function () {
        console.log('detaching...', this.pattern);
        removeEventListener('url-router-history-change', this.changeEventHandler);
        removeEventListener('popstate', this.changeEventHandler);
        removeEventListener('hashchange', this.changeEventHandler);
      },
      routeChanges: function () {
        var result = this.matchRoute();
        if (result == null && this.model == null) {
          return false;
        }
        if (result == null) {
          return null;
        }
        else if (this.model == null) {
          return result;
        }

        var modelKeys = Object.keys(this.model),
            resultKeys = Object.keys(result);

        if (modelKeys.length !== resultKeys.length) {
          return result;
        }

        var total = modelKeys.length,
            key, i;
        for (i = 0; i < total; i++) {
          key = modelKeys[i];
          if (this.model[key] !== result[key]) {
            return result;
          }
        }
        return false;
      },
      matchRoute: function () {
        if (!this.urlParser) {
          this.urlParser = this.processPattern();
        }
        return this.urlParser(document.location) || null;
      },
      processPattern: function () {
        var pattern = this.pattern,
            defaultParams = {},
            extracted = this.extractPatternReferences(pattern),
            regexp = extracted[0],
            patterns = extracted[1],
            names = extracted[2];

        return this.createUrlParser(regexp, names, defaultParams);
      },
      createUrlParser: function (regexp, names, defaultParams) {
        var paramNames = Object.keys(defaultParams || {}),
            totalParams = paramNames.length;
        return function (url) {
          var parsed = new URL(url),
              params = {},
              pathname = parsed.pathname,
              matches, total, name, i;

          if ((matches = /\.(\w+|-)$/.exec(pathname))) {
            pathname = pathname.slice(0, matches.index);
          }

          matches = pathname.match(regexp);


          if (!matches) {
            return false;
          }
          total = matches.length - 1;
          if (total > 0) {
            for (i = 0; i < total; i++) {
              name = names[i];
              params[name] = matches[i + 1];
            }
          }
          if (parsed.search) {
            params = queryString.parse(parsed.search);
          }
          if (totalParams) {
            for (i = 0; i < totalParams; i++) {
              name = paramNames[i];
              params[name] = params[name] || defaultParams[name];
            }
          }
          if (parsed.hash) {
            params['#'] = parsed.hash.slice(1);
          }
          return params;
        };
      },
      extractPatternReferences: function (pattern) {
        var referencePattern = /([^<]+)?<(\w+)(:([^>]+))?>([^<]+)?/g,
            escaper = /[-[\]{}()*+?.,\\^$|#\s]/g,
            parts = [],
            patterns = [],
            names = [],
            matches, prefix, suffix, name, regexPart;

        pattern = trim(pattern, '/');

        while ((matches = referencePattern.exec(pattern))) {
          if (matches[1] != null) {
            prefix = matches[1].replace(escaper, '\\$&');
          }
          else {
            prefix = '';
          }

          name = matches[2];

          if (matches[4] != null) {
            if (/^\((.*)\)$/.test(matches[4])) {
              regexPart = matches[4];
            }
            else {
              regexPart = '(' + matches[4] + ')';
            }
          }
          else {
            regexPart = '([^\\/]+)';
          }

          if (matches[5] != null) {
            suffix = matches[5].replace(escaper, '\\$&');
          }
          else {
            suffix = '';
          }
          names.push(name);
          parts.push(prefix, regexPart, suffix);
          patterns.push(prefix, [name, regexPart], suffix);
        }

        if (names.length === 0) {
          parts.push(pattern.replace(escaper, '\\$&'));
        }
        return [new RegExp("^\/" + parts.join('') + "[/]?$"), patterns, names];
      },
      makeSyntax: function() {
        var events = Object.create(Polymer.api.declaration.events);
        var self = this;
        events.findController = function() { return self.model; };

        var syntax = new PolymerExpressions();
        var prepareBinding = syntax.prepareBinding;
        syntax.prepareBinding = function(pathString, name, node) {
          return events.prepareEventBinding(pathString, name, node) ||
                 prepareBinding.call(syntax, pathString, name, node);
        };
        return syntax;
      }
    });
  })();

  </script>

</polymer-element>
